Ты запутался когда следовал плану QUERY.md
Я частично разобрался в ситуации, главная проблема твоей путаницы - ты ввел аксиомы которые не соответствуют реальности (можешь найти коммантирии со словом АКСИОМА, и следуя этому перепутал всё дальше в ожиданиях тестов и стал путать в реализации. Предлагаю следующий план:

--- ЭТАП 1

Я описываю нижу реальные АКСИОМЫ и ты их фиксируешь в QUERY.md

Аксиома ассоциатинвых отношений

A = new deep(); a1 = new A(); a2 = new A();
a1.type возвращает тип ассоциации A либо undefined (undefined может быть только у корневой ассоциации)
A.typed возвращает сет тех кто типизирован данной ассоциацией { a1, a2 }

B = new deep(); b1 = new B(); b2 = new B(); b1.from = a1; b2.from = a1;
b1.from возвращает то куда данная ассоциация ссылается как на from - a1 или если не указано undefined
a1.out возвращает сет тех кто ссылается на данную ассоциацию как на from { b1, b2 }

C = new deep(); c1 = new C(); c2 = new C(); c1.to = a2; c2.to = a2;
c1.to возвращает то куда данная ассоциация ссылается как на to - a2 или если не указано undefined
a2.in возвращает сет тех кто ссылается на данную ассоциацию как на to { c1, c2 }

str = new deep.String('abc');
D = new deep(); d1 = new D(); d2 = new D(); d1.value = str; d2.value = str;
d1.value возвращает то куда данная ассоциация ссылается как на .value - str или если не указано undefined
str.valued возвращает сет тех кто ссылается на данную ассоциацию как на value { d1, d2 }

Аксиома manyRelation. Работает как и обычные релейшены, НО если оычные возвращают для одиночны указателей один элемент а для множественных deep.set то manyRelation предназначен привести это к одному стандарту и всегда возвращать deep.Set поддерживающий трекинг. Таким образом все что описано выше верно и для manyRelation, и должно соответствовать следующей сигнатуре:

a1.manyRelation('type') // { A }
A.manyRelation('typed') // { a1, a2 }

b1.manyRelation('from') // { a1 }
a1.manyRelation('out') // { b1, b2 }

c1.manyRelation('to') // { a2 }
a2.manyRelation('in') // { c1, c2 }

d1.manyRelation('value') // { str }
str.manyRelation('valued') // { d1, d2 }

При этом если менять исходные указатели и проверять после этого получающийся результат - он должен меняться. Например делая delete d1.value, d1 должен пропадать из str.manyRelation('valued') ранее полученного результата оставляя только d2, и str должен исчезнуть из d1.manyRelation('value') результата оставляя сет пустым. И если вернуть ему value - d1.value = str, d1 должен вернуться в сет valued, а str вернутся в сет value. Это нужно проверить для каддого из случаев.

Аксиома mapByField метода.
Вызывается из deepSet полученного например из testDeepSet = a2.manyRelation('out') { b1, b2 }.
Таким образом для каждого из результатов он выполнит manyRelation по указанному ключу 
mappedByField = testDeepSet.mapByField('from') => { { a1 }, { a1 } }
На этом этапе мы должны проверить и быть увреены что следующий шаг рабоатет: преобразование этого в плоский список результатов используя deep.Or:
new deep.Or(undefined, mappedByField) должен вернуть { a1 }

Аксиома queryField(fieldName, value) метода. Если manyRelation буквально из ассоциации дает то что по указанному филд-релейшену только в формате реактивного поддерживающего трекинг сета, то queryField отвечает на другой вопрос:
Вопрос к manyRelation - дай то что по указателю.
Вопрос к queryField - дай тех у кого этот указатель соответствует описанию.

То есть основываясь на датасете выше:

deep.queryField('type', A) // { a1, a2 }
Потому что в данном случае когда value это instanceof deep.Deep -  A.manyRelation(invertedFieldName) - { a1, a2 }

Найди тех на кого value ссылается по type
deep.queryField('typed', a1) // { A }
Потому что в данном случае когда value это instanceof deep.Deep -  a1.manyRelation(invertedFieldName) - { A }

До реализации query если в queryField передан value instanceof deep.Deep это единственный сценарий, для тестов и в реализации если value не instanceof deep.Deep нужно выдавать ошибку.

После мы реализовываем query начального уровня.
Аксиома deep.query({ [fieldName]: value }) в том что он просто получает exp обьект проверяет что он plain object, делает по нему цикл, формирует parsedExp { [fieldName]: deepSet } вызывая для каждой пары fieldName value конструкцию deep.queryField(fieldName, value), а после вычисления - return new deep.And(undefined, new Set([...Object.values(parsedExp)])) таким образом обощая результат.

Это значит что по порядку на том-же датасете выше (к стати для теста я бы сделал const { A, a1, a2, B, b1, b2, C, c1, c2, D, d1, d2, str } = makeDataset(deep)): что бы каждый раз работать с одним и тем же датасетом удобно зная что он одинаковый.

deep.query({ type: A }) // { a1, a2 }
deep.query({ typed: a1 }) // { A }

deep.query({ type: A, out: b1 }); // { a1 } 
Потому что он ищет те связи у которых тип A и на которые ссылаются по from b1

Мы удаляем и полностью переписываем тесты в соответствии со следующей логикой:

describe имя метода
it проверка one & many отношения используя указанный метод, и проверка их поддержки трекинга (результат должен меняться при изменении обстоятельств синхронно корректно). Каждый it должен проверять один тестовый случай как я описал выше но проверять и с позиции соответствия результата и с позиции что при изменении обстоятельств результирующий сет меняется и у него срабатывают события added deleted.

Но начинаем с того что бы расширить этот SELECT2.md файл, всеми комбинациями которые я не указал для deep.queryField и deep.query и рядом описать ожидаемые результаты, я проверю что ожидания корректны в каждом случае на том-же датасете.

--- ЭТАП 2

Реализация вложенных запросов

Теперь когда мы знаем что deep.queryField и deep.query работают корректно и полностью протестированы, не раньше, мы можем сделать следующее:

Расширить условие value у deep.queryField. Если раньше мы разрешали value ТОЛЬКО instanceof deep.Deep теперь разрешен еще plain object который точно не instanceof deep.Deep.

В таком случае применяется альтернативный сценарий. Именно в этом случае потребуется mapByField.
Например:
deep.query({ out: { type: B } }) передаст в deep.queryField('out', { type: B }) где внутри из-за того что это plain object выполнится deep.query({ type: B }) который вернет { b1, b2 }, но это еще не результат deep.queryField('out', { type: B }). Теперь нужно взять deepSet полученный из этого deep.query ({ b1, b2 }) и сделать от него deepSet.mapByField(_invertFields[fieldName]), таким образом раз fieldName deep.queryField('out', { type: B }) - 'out' его инверсия удет 'from', а mapByField сделает цикл по результатам от query и получит сет сетов const mappedDeepSet = {{ a1 }, { a1 }}, и нам останется только сделать return new deep.Or(undefined, mapeedDeepSet).