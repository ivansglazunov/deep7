import { Deep, deep } from './';

describe('deep', () => {
  it('() unpacking data', () => {
    const a = deep();
    const b = deep();
    expect(a).toBe(b);
    expect(a).toBe(deep.symbol);
    expect(b).toBe(deep.symbol);
  });
  it('new () creation', () => {
    const a = deep();
    const b = new deep();
    const c = new deep();
    expect(a).toBe(deep.symbol);
    expect(b).not.toBe(c);
    expect(b.symbol).not.toBe(c.symbol);
    expect(b.prev).toBe(deep.symbol);
    expect(b.prevBy).toBe(deep.construct);
    expect(c.prev).toBe(deep.symbol);
    expect(c.prevBy).toBe(deep.construct);
  });
  it('new () context', () => {
    const a = new deep();
    const b = new a();
    const c = new a();
    expect(b.context).not.toBe(c.context);
    a.context.x = 1;
    expect(b.x).toBe(1);
    expect(c.x).toBe(1);
    b.context.y = 2;
    expect(b.y).toBe(2);
    expect(c.y).not.toBe(2);
    expect(a.prev).toBe(deep.symbol);
    expect(b.prev).toBe(a.symbol);
    expect(c.prev).toBe(a.symbol);
    expect(a.prevBy).toBe(deep.construct);
    expect(b.prevBy).toBe(deep.construct);
    expect(c.prevBy).toBe(deep.construct);
  });
  it('() context', () => {
    const A = new deep();
    expect(A.prev).toBe(deep.symbol);
    expect(A.prevBy).toBe(deep.construct);
    expect(A instanceof Deep).toBe(true);
    expect(A.this).toBe(deep.this);
    A.x = 1;
    expect(A.x).toBe(1);
    const a = new A();
    expect(a.this).toBe(A.this);
    expect(a.x).toBe(1);
    const B = new deep();
    expect(B.this).toBe(deep.this);
    B.x = 2;
    a.context = B.context;
    expect(a.x).toBe(2);
    expect(a.prev).toBe(A.symbol);
    expect(a.prevBy).toBe(deep.construct);
  });
  it('new () context', () => {
    const A = new deep();
    expect(A instanceof Deep).toBe(true);
    expect(A.this).toBe(deep.this);
    A.x = 1;
    expect(A.x).toBe(1);
    const a = new A();
    expect(a.this).toBe(A.this);
    expect(a.x).toBe(1);
    const B = new deep();
    expect(B.this).toBe(deep.this);
    B.x = 2;
    a.context = B.context;
    expect(a.x).toBe(2);
    expect(A.x).toBe(1);
  });
  it('new () many contexts', () => {
    const A = new deep();
    const B = new A();
    const C = new B();
    A.x = 1;
    B.y = 2;
    C.z = 3;
    expect(C.z).toBe(3);
    expect(C.y).toBe(2);
    expect(C.x).toBe(1);
    expect(A.prev).toBe(deep.symbol);
    expect(B.prev).toBe(A.symbol);
    expect(C.prev).toBe(B.symbol);
  });
  it('deep.undefined', () => {
    const a = deep.undefined();
    const b = deep.undefined();
    expect(a).toBe(b);
    expect(a).toBe(deep.undefined.symbol);
    const v1 = undefined;
    const x = new deep.undefined(v1);
    const y = new deep.undefined(v1);
    const v2 = undefined;
    const z = new deep.undefined(v2);
    expect(x.data).toBe(undefined);
    expect(y.data).toBe(undefined);
    expect(z.data).toBe(undefined);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).toBe(z.symbol);
    expect(() => new deep.undefined(123)).toThrow('!undefined');
  });
  it('deep.null', () => {
    const a = deep.null();
    const b = deep.null();
    expect(a).toBe(b);
    expect(a).toBe(deep.null.symbol);
    const v1 = null;
    const x = new deep.null(v1);
    const y = new deep.null(v1);
    const v2 = null;
    const z = new deep.null(v2);
    expect(x.data).toBe(null);
    expect(y.data).toBe(null);
    expect(z.data).toBe(null);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).toBe(z.symbol);
    expect(() => new deep.null(123)).toThrow('!null');
  });
  it('deep.Boolean', () => {
    const a = deep.Boolean();
    const b = deep.Boolean();
    expect(a).toBe(b);
    expect(a).toBe(deep.Boolean.symbol);
    const v1 = true;
    const v2 = false;
    const x = new deep.Boolean(v1);
    const y = new deep.Boolean(v1);
    const z = new deep.Boolean(v2);
    expect(x.data).toBe(true);
    expect(y.data).toBe(true);
    expect(z.data).toBe(false);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(() => new deep.Boolean(123)).toThrow('!boolean');
  });
  it('deep.Number', () => {
    const a = deep.Number();
    const b = deep.Number();
    expect(a).toBe(b);
    expect(a).toBe(deep.Number.symbol);
    const v1 = 123;
    const x = new deep.Number(v1);
    const y = new deep.Number(v1);
    const v2 = 234;
    const z = new deep.Number(v2);
    expect(x.data).toBe(123);
    expect(y.data).toBe(123);
    expect(z.data).toBe(234);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Number.symbol);
    expect(y.prev).toBe(deep.Number.symbol);
    expect(z.prev).toBe(deep.Number.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.Number('abc')).toThrow('!number');
  });
  it('deep.NaN', () => {
    const a = deep.NaN();
    const b = deep.NaN();
    expect(a).toBe(b);
    expect(a).toBe(deep.NaN.symbol);
    const v1 = NaN;
    const x = new deep.NaN(v1);
    const y = new deep.NaN(v1);
    const v2 = NaN;
    const z = new deep.NaN(v2);
    expect(x.data).toBe(NaN);
    expect(y.data).toBe(NaN);
    expect(z.data).toBe(NaN);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).toBe(z.symbol);
    expect(x.prev).toBe(deep.NaN.symbol);
    expect(y.prev).toBe(deep.NaN.symbol);
    expect(z.prev).toBe(deep.NaN.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.NaN(123)).toThrow('!NaN');
  });
  it('deep.Infinity', () => {
    const a = deep.Infinity();
    const b = deep.Infinity();
    expect(a).toBe(b);
    expect(a).toBe(deep.Infinity.symbol);
    const v1 = Infinity;
    const x = new deep.Infinity(v1);
    const y = new deep.Infinity(v1);
    const v2 = -Infinity;
    const z = new deep.Infinity(v2);
    expect(x.data).toBe(Infinity);
    expect(y.data).toBe(Infinity);
    expect(z.data).toBe(-Infinity);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Infinity.symbol);
    expect(y.prev).toBe(deep.Infinity.symbol);
    expect(z.prev).toBe(deep.Infinity.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.Infinity(123)).toThrow('!Infinity');
  });
  it('deep.String', () => {
    const a = deep.String();
    const b = deep.String();
    expect(a).toBe(b);
    expect(a).toBe(deep.String.symbol);
    const v1 = '123';
    const x = new deep.String(v1);
    const y = new deep.String(v1);
    const v2 = '234';
    const z = new deep.String(v2);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.String.symbol);
    expect(y.prev).toBe(deep.String.symbol);
    expect(z.prev).toBe(deep.String.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.String(123)).toThrow('!string');
  });
  it('deep.Symbol', () => {
    const a = deep.Symbol();
    const b = deep.Symbol();
    expect(a).toBe(b);
    expect(a).toBe(deep.Symbol.symbol);
    const v1 = Symbol('123');
    const x = new deep.Symbol(v1);
    const y = new deep.Symbol(v1);
    const v2 = Symbol('234');
    const z = new deep.Symbol(v2);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Symbol.symbol);
    expect(y.prev).toBe(deep.Symbol.symbol);
    expect(z.prev).toBe(deep.Symbol.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.Symbol(123)).toThrow('!symbol');
    const self = new deep.Symbol(x.symbol);
    expect(self.symbol).toBe(self.data);
    expect(self.symbol).toBe(x.symbol);
  });
  it('deep.Array', () => {
    const a = deep.Array();
    const b = deep.Array();
    expect(a).toBe(b);
    expect(a).toBe(deep.Array.symbol);
    const v1 = [1, 2, 3];
    const x = new deep.Array(v1);
    const y = new deep.Array(v1);
    const v2 = [4, 5, 6];
    const z = new deep.Array(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Array.symbol);
    expect(y.prev).toBe(deep.Array.symbol);
    expect(z.prev).toBe(deep.Array.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.Array(123)).toThrow('!array');
  });
  it('deep.Object', () => {
    const a = deep.Object();
    const b = deep.Object();
    expect(a).toBe(b);
    expect(a).toBe(deep.Object.symbol);
    const v1 = { a: 1, b: 2, c: 3 };
    const x = new deep.Object(v1);
    const y = new deep.Object(v1);
    const v2 = { a: 1, b: 2, c: 3 };
    const z = new deep.Object(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Object.symbol);
    expect(y.prev).toBe(deep.Object.symbol);
    expect(z.prev).toBe(deep.Object.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.Object(123)).toThrow('!object');
  });
  it('deep.Promise', () => {
    const a = deep.Promise();
    const b = deep.Promise();
    expect(a).toBe(b);
    expect(a).toBe(deep.Promise.symbol);
    const v1 = new Promise(res => res(undefined));
    const x = new deep.Promise(v1);
    const y = new deep.Promise(v1);
    const v2 = new Promise(res => res(undefined));
    const z = new deep.Promise(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Promise.symbol);
    expect(y.prev).toBe(deep.Promise.symbol);
    expect(z.prev).toBe(deep.Promise.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.Promise(123)).toThrow('!promise');
  });
  it('deep.Map', () => {
    const a = deep.Map();
    const b = deep.Map();
    expect(a).toBe(b);
    expect(a).toBe(deep.Map.symbol);
    const v1 = new Map();
    const x = new deep.Map(v1);
    const y = new deep.Map(v1);
    const v2 = new Map();
    const z = new deep.Map(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Map.symbol);
    expect(y.prev).toBe(deep.Map.symbol);
    expect(z.prev).toBe(deep.Map.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.Map(123)).toThrow('!map');
  });
  it('deep.WeakMap', () => {
    const a = deep.WeakMap();
    const b = deep.WeakMap();
    expect(a).toBe(b);
    expect(a).toBe(deep.WeakMap.symbol);
    const v1 = new WeakMap();
    const x = new deep.WeakMap(v1);
    const y = new deep.WeakMap(v1);
    const v2 = new WeakMap();
    const z = new deep.WeakMap(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.WeakMap.symbol);
    expect(y.prev).toBe(deep.WeakMap.symbol);
    expect(z.prev).toBe(deep.WeakMap.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.WeakMap(123)).toThrow('!weakMap');
  });
  it('deep.Set', () => {
    const a = deep.Set();
    const b = deep.Set();
    expect(a).toBe(b);
    expect(a).toBe(deep.Set.symbol);
    const v1 = new Set();
    const x = new deep.Set(v1);
    const y = new deep.Set(v1);
    const v2 = new Set();
    const z = new deep.Set(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Set.symbol);
    expect(y.prev).toBe(deep.Set.symbol);
    expect(z.prev).toBe(deep.Set.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.Set(123)).toThrow('!set');
  });
  it('deep.WeakSet', () => {
    const a = deep.WeakSet();
    const b = deep.WeakSet();
    expect(a).toBe(b);
    expect(a).toBe(deep.WeakSet.symbol);
    const v1 = new WeakSet();
    const x = new deep.WeakSet(v1);
    const y = new deep.WeakSet(v1);
    const v2 = new WeakSet();
    const z = new deep.WeakSet(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.WeakSet.symbol);
    expect(y.prev).toBe(deep.WeakSet.symbol);
    expect(z.prev).toBe(deep.WeakSet.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.WeakSet(123)).toThrow('!weakSet');
  });
  it('deep.Date', () => {
    const a = deep.Date();
    const b = deep.Date();
    expect(a).toBe(b);
    expect(a).toBe(deep.Date.symbol);
    const v1 = new Date();
    const x = new deep.Date(v1);
    const y = new deep.Date(v1);
    const v2 = new Date();
    const z = new deep.Date(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Date.symbol);
    expect(y.prev).toBe(deep.Date.symbol);
    expect(z.prev).toBe(deep.Date.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.Date(123)).toThrow('!date');
  });
  it('deep.RegExp', () => {
    const a = deep.RegExp(/a/);
    const b = deep.RegExp(/a/);
    expect(a).toBe(b);
    expect(a).toBe(deep.RegExp.symbol);
    const v1 = /a/;
    const x = new deep.RegExp(v1);
    const y = new deep.RegExp(v1);
    const v2 = new RegExp(/a/);
    const z = new deep.RegExp(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.RegExp.symbol);
    expect(y.prev).toBe(deep.RegExp.symbol);
    expect(z.prev).toBe(deep.RegExp.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.RegExp(123)).toThrow('!RegExp');
  });
  it('deep.Error', () => {
    const a = deep.Error();
    const b = deep.Error();
    expect(a).toBe(b);
    expect(a).toBe(deep.Error.symbol);
    const v1 = new Error();
    const x = new deep.Error(v1);
    const y = new deep.Error(v1);
    const v2 = new Error();
    const z = new deep.Error(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Error.symbol);
    expect(y.prev).toBe(deep.Error.symbol);
    expect(z.prev).toBe(deep.Error.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.Error(123)).toThrow('!error');
  });
  const isBufferAvailable = typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function';
  (isBufferAvailable ? it : it.skip)('deep.Buffer', () => {
    const a = deep.Buffer();
    const b = deep.Buffer();
    expect(a).toBe(b);
    expect(a).toBe(deep.Buffer.symbol);
    const v1 = Buffer.from([1, 2, 3]);
    const x = new deep.Buffer(v1);
    const y = new deep.Buffer(v1);
    const v2 = Buffer.from([4, 5, 6]);
    const z = new deep.Buffer(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Buffer.symbol);
    expect(y.prev).toBe(deep.Buffer.symbol);
    expect(z.prev).toBe(deep.Buffer.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.Buffer([1, 2, 3])).toThrow('!Buffer');
  });
  
  it('deep.ArrayBuffer', () => {
    const a = deep.ArrayBuffer();
    const b = deep.ArrayBuffer();
    expect(a).toBe(b);
    expect(a).toBe(deep.ArrayBuffer.symbol);
    const v1 = new ArrayBuffer(8);
    const x = new deep.ArrayBuffer(v1);
    const y = new deep.ArrayBuffer(v1);
    const v2 = new ArrayBuffer(16);
    const z = new deep.ArrayBuffer(v2);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.ArrayBuffer.symbol);
    expect(y.prev).toBe(deep.ArrayBuffer.symbol);
    expect(z.prev).toBe(deep.ArrayBuffer.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
      expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.ArrayBuffer([1, 2, 3])).toThrow('!ArrayBuffer');
  });
  
  it('deep.TypedArray', () => {
    const a = deep.TypedArray();
    const b = deep.TypedArray();
    expect(a).toBe(b);
    expect(a).toBe(deep.TypedArray.symbol);
    const v1 = new Uint8Array([1, 2, 3]);
    const x = new deep.TypedArray(v1);
    const y = new deep.TypedArray(v1);
    const v2 = new Float32Array([4, 5, 6]);
    const z = new deep.TypedArray(v2);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.TypedArray.symbol);
    expect(y.prev).toBe(deep.TypedArray.symbol);
    expect(z.prev).toBe(deep.TypedArray.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.TypedArray([1, 2, 3])).toThrow('!TypedArray');
    expect(() => new deep.TypedArray(new DataView(new ArrayBuffer(8)))).toThrow('!TypedArray');
  });
  
  it('deep.DataView', () => {
    const a = deep.DataView();
    const b = deep.DataView();
    expect(a).toBe(b);
    expect(a).toBe(deep.DataView.symbol);
    const v1 = new DataView(new ArrayBuffer(8));
    const x = new deep.DataView(v1);
    const y = new deep.DataView(v1);
    const v2 = new DataView(new ArrayBuffer(16));
    const z = new deep.DataView(v2);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.DataView.symbol);
    expect(y.prev).toBe(deep.DataView.symbol);
    expect(z.prev).toBe(deep.DataView.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.DataView([1, 2, 3])).toThrow('!DataView');
    expect(() => new deep.DataView(new Uint8Array([1, 2, 3]))).toThrow('!DataView');
  });
  
  const isBlobAvailable = typeof Blob !== 'undefined';
  (isBlobAvailable ? it : it.skip)('deep.Blob', () => {
    const a = deep.Blob();
    const b = deep.Blob();
    expect(a).toBe(b);
    expect(a).toBe(deep.Blob.symbol);
    const v1 = new Blob(['abc']);
    const x = new deep.Blob(v1);
    const y = new deep.Blob(v1);
    const v2 = new Blob(['def']);
    const z = new deep.Blob(v2);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Blob.symbol);
    expect(y.prev).toBe(deep.Blob.symbol);
    expect(z.prev).toBe(deep.Blob.symbol);
    expect(x.prevBy).toBe(deep.construct);
    expect(y.prevBy).toBe(deep.construct);
    expect(z.prevBy).toBe(deep.construct);
    expect(() => new deep.Blob([1, 2, 3])).toThrow('!Blob');
  });
  it('deep.Function', () => {
    const a = deep.Function();
    const b = deep.Function();
    expect(a).toBe(b);
    expect(a).toBe(deep.Function.symbol);
    const v1 = () => 123;
    const x = new deep.Function(v1);
    const y = new deep.Function(v1);
    const v2 = () => 123;
    const z = new deep.Function(v2);
    expect(x.context.__proto__).toStrictEqual(deep.Function.context);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.data).not.toBe(z.data);
    expect(x.prev).toBe(deep.Function.symbol);
    expect(y.prev).toBe(deep.Function.symbol);
    expect(z.prev).toBe(deep.Function.symbol);
    expect(() => new deep.Function(123)).toThrow('!function');
  });
});

// describe('deep', () => {
//   it('recreation', () => {
//     expect(deep).toBeInstanceOf(Deep);
//     expect(deep.this).toBeInstanceOf(Function);
//     expect(deep.this).toBe(create);
//     expect(deep()).toBeInstanceOf(Deep);
//     expect(deep().this).toBe(create);
//     expect(new deep).toBeInstanceOf(Deep);
//     expect((new deep).this).toBe(create);
//     expect(new deep()).toBeInstanceOf(Deep);
//     expect(new deep().this).toBe(create);
//     expect(deep()()()()()()().this).toBe(create); // Return self if nothing
//     expect(deep(undefined).this).toBe(undefined);
//     expect((new new new new new new new deep).this).toBe(create);
//     expect((new (new (new (new (new (new (new deep())())())())())())()).this).toBe(create);
//   });
//   it('this call', () => {
//     const d123 = deep(123);
//     expect(d123.this).toBe(123);
//     expect(d123()().this).toBe(123);
//     expect(d123()()()().this).toBe(123);
//     expect(d123()()()()() == d123).toBe(true);
//   });
//   it('this new', () => {
//     const D123 = new deep(123);
//     expect(D123().this).toBe(123)
//     expect(D123()()()()().this).toBe(123)
//     expect(D123.this).toBe(123);
//     expect(new D123).toBeInstanceOf(Deep);
//     expect((new D123).this).toBe(create);
//     expect(new D123(/* not described how to construct */).this).toBe(create);
//     expect(new D123(234).this).toBe(234);
//     expect(new D123(234)()().this).toBe(234);
//     let B123C;
//     function construct (a, b, c) {
//       expect(this).toBe(B123C);
//       expect(a).toBe(1);
//       expect(b).toBe(2);
//       expect(c).toBe(3);
//       return a + b + c;
//     };
//     B123C = new D123(construct);
//     expect(B123C.this).toBe(construct);
//     expect(B123C(1, 2, 3)).toBe(6);
//     expect(new B123C(1, 2, 3).this).toBe(6);
//     expect(new B123C(1, 2, 3)()().this).toBe(6);
//   });
//   it('new () - same this with context inheritance', () => {
//     const A = new deep();
//     expect(A instanceof Deep).toBe(true);
//     expect(A.this).toBe(deep.this);
//     A.x = 1;
//     expect(A.x).toBe(1);
//     const a = new A();
//     expect(a.this).toBe(A.this);
//     expect(a.x).toBe(1);
//     const B = new deep();
//     expect(B.this).toBe(deep.this);
//     B.x = 2;
//     a.context = B.context;
//     expect(a.x).toBe(2);
//   });
//   it('new (fn) - construct this with context inheritance', () => {
//     const A = new deep(() => 123);
//     const a = new A();
//     expect(a.this).toBe(123);
//     const B = new deep((x, y) => x + y);
//     const b = new B(1, 2);
//     // b is result of calc 1 + 2 and inherit B
//     expect(b.this).toBe(3);
//     expect(new b().this).toBe(create);
//     expect(new b(5).this).toBe(5);
//     // we can make b not only value, but also constructor
//     b._construct = deep((deep, z) => create(+deep.this + +z));
//     expect(b.this).toBe(3);
//     const c = new b(4); // constructor sum 3 + 4
//     expect(c.this).toBe(7);
//   });
//   it('() - same this without context inheritance', () => {
//     expect(typeof deep.this).toBe('function');
//     const A = deep();
//     expect(A.this).toBe(deep.this);
//     A.x = 1;
//     expect(A.x).toBe(1);
//     const a = A();
//     expect(a.this).toBe(A.this);
//     expect(a.x).toBe(undefined);
//     const B = deep();
//     expect(B.this).toBe(deep.this);
//     B.x = 2;
//     a.context = B.context;
//     expect(a.x).toBe(2);
//   });
//   it('in context', () => {
//     const A = deep();
//     A.x = 1;
//     expect('x' in A).toBe(true);
//     expect('y' in A).toBe(false);
//   });
//   it('instance proxy', () => {
//     const A = deep();
//     expect(A.proxy).toBe(A);
//     const instance = A.instance;
//     expect(instance).not.toBe(deep);
//     expect(instance).not.toBe(deep.proxy);
//     expect(instance.proxy).toBe(A);
//   });
//   it('unwrap', () => {
//     const A = new deep(1);
//     A.x = 2;
//     expect(unwrap(A)).toBe(1);
//     expect(unwrap(A.x)).toBe(2);
//   });
//   it('wrap', () => {
//     const A = deep();
//     A.x = 1;
//     expect(wrap(A) instanceof Deep).toBe(true);
//     expect(wrap(A.x) instanceof Deep).toBe(true);
//   });
//   it('new getter(fn)', () => {
//     const A = new deep();
//     let expectDeep = A;
//     A.x = new getter((deep, key) => {
//       expect(key).toBe('x');
//       expect(deep).toBe(expectDeep);
//       return 123;
//     });
//     expect(A.x).toBe(123);
//   });
//   it('new setter(fn)', () => {
//     const A = new deep();
//     let expectDeep = A;
//     let checkValue;
//     A.x = new setter((deep, key, value) => {
//       expect(key).toBe('x');
//       expect(deep).toBe(expectDeep);
//       expect(value).toBe(123);
//       checkValue = value;
//       return true;
//     });
//     A.x = 123;
//     expect(checkValue).toBe(123);
//   });
//   it('setter(fn) wrong', () => {
//     const A = new deep();
//     let expectDeep = A;
//     let checkValue;
//     A.x = setter((deep, key, value) => {
//       expect(key).toBe('x');
//       expect(deep).toBe(expectDeep);
//       expect(value).toBe(123);
//       checkValue = value;
//       return true;
//     });
//     A.x = 123;
//     expect(checkValue).toBe(undefined);
//     expect(A.x).toBe(123);
//     expect(A.context.x).toBe(123);
//   });
// });
