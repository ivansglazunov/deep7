import { Deep, deep } from '.';

describe('js', () => {
  it('deep.Undefined', () => {
    const a = deep.Undefined();
    const b = deep.Undefined();
    expect(a).toBe(undefined);
    const v1 = undefined;
    const x = new deep.Undefined(v1);
    const y = new deep.Undefined(v1);
    const v2 = undefined;
    const z = new deep.Undefined(v2);
    expect(x.data).toBe(undefined);
    expect(y.data).toBe(undefined);
    expect(z.data).toBe(undefined);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).toBe(z.symbol);
    expect(() => new deep.Undefined(123)).toThrow('!Undefined');
    expect(x.symbol).toBe(deep.undefined.symbol);
  });
  it('deep.null', () => {
    const a = deep.null();
    const b = deep.null();
    expect(a).toBe(undefined);
    const v1 = null;
    const x = new deep.null(v1);
    const y = new deep.null(v1);
    const v2 = null;
    const z = new deep.null(v2);
    expect(x.data).toBe(null);
    expect(y.data).toBe(null);
    expect(z.data).toBe(null);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).toBe(z.symbol);
    expect(() => new deep.null(123)).toThrow('!Null');
  });
  it('deep.Boolean', () => {
    const a = deep.Boolean();
    const b = deep.Boolean();
    expect(a).toBe(undefined);
    const v1 = true;
    const v2 = false;
    const x = new deep.Boolean(v1);
    const y = new deep.Boolean(v1);
    const z = new deep.Boolean(v2);
    expect(x.data).toBe(true);
    expect(y.data).toBe(true);
    expect(z.data).toBe(false);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(() => new deep.Boolean(123)).toThrow('!Boolean');
  });
  it('deep.Number', () => {
    const a = deep.Number();
    const b = deep.Number();
    expect(a).toBe(undefined);
    const v1 = 123;
    const x = new deep.Number(v1);
    const y = new deep.Number(v1);
    const v2 = 234;
    const z = new deep.Number(v2);
    expect(x.data).toBe(123);
    expect(y.data).toBe(123);
    expect(z.data).toBe(234);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Number.symbol);
    expect(y.prev).toBe(deep.Number.symbol);
    expect(z.prev).toBe(deep.Number.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.Number('abc')).toThrow('!Number');
  });
  it('deep.NaN', () => {
    const a = deep.NaN();
    const b = deep.NaN();
    expect(a).toBe(undefined);
    const v1 = NaN;
    const x = new deep.NaN(v1);
    const y = new deep.NaN(v1);
    const v2 = NaN;
    const z = new deep.NaN(v2);
    expect(x.data).toBe(NaN);
    expect(y.data).toBe(NaN);
    expect(z.data).toBe(NaN);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).toBe(z.symbol);
    expect(x.prev).toBe(deep.NaN.symbol);
    expect(y.prev).toBe(deep.NaN.symbol);
    expect(z.prev).toBe(deep.NaN.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.NaN(123)).toThrow('!NaN');
  });
  it('deep.Infinity', () => {
    const a = deep.Infinity();
    const b = deep.Infinity();
    expect(a).toBe(undefined);
    const v1 = Infinity;
    const x = new deep.Infinity(v1);
    const y = new deep.Infinity(v1);
    const v2 = -Infinity;
    const z = new deep.Infinity(v2);
    expect(x.data).toBe(Infinity);
    expect(y.data).toBe(Infinity);
    expect(z.data).toBe(-Infinity);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Infinity.symbol);
    expect(y.prev).toBe(deep.Infinity.symbol);
    expect(z.prev).toBe(deep.Infinity.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.Infinity(123)).toThrow('!Infinity');
  });
  it('deep.String', () => {
    const a = deep.String();
    const b = deep.String();
    expect(a).toBe(undefined);
    const v1 = '123';
    const x = new deep.String(v1);
    const y = new deep.String(v1);
    const v2 = '234';
    const z = new deep.String(v2);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.String.symbol);
    expect(y.prev).toBe(deep.String.symbol);
    expect(z.prev).toBe(deep.String.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.String(123)).toThrow('!String');
  });
  it('deep.Symbol', () => {
    const a = deep.Symbol();
    const b = deep.Symbol();
    expect(a).toBe(undefined);
    const v1 = Symbol('123');
    const x = new deep.Symbol(v1);
    const y = new deep.Symbol(v1);
    const v2 = Symbol('234');
    const z = new deep.Symbol(v2);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Symbol.symbol);
    expect(y.prev).toBe(deep.Symbol.symbol);
    expect(z.prev).toBe(deep.Symbol.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.Symbol(123)).toThrow('!Symbol');
    const other = new deep.Symbol(x.symbol);
    expect(other.symbol).not.toBe(other.data);
    expect(other.symbol).not.toBe(x.symbol);
    expect(other.data).toBe(x.symbol);
    const self = new deep(x.symbol);
    expect(self.symbol).not.toBe(self.data);
    expect(self.data).toBe(v1);
  });
  it('deep.Array', () => {
    const a = deep.Array();
    const b = deep.Array();
    expect(a).toBe(undefined);
    const v1 = [1, 2, 3];
    const x = new deep.Array(v1);
    const y = new deep.Array(v1);
    const v2 = [4, 5, 6];
    const z = new deep.Array(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Array.symbol);
    expect(y.prev).toBe(deep.Array.symbol);
    expect(z.prev).toBe(deep.Array.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.Array(123)).toThrow('!Array');
  });
  it('deep.Object', () => {
    const a = deep.Object();
    const b = deep.Object();
    expect(a).toBe(undefined);
    const v1 = { a: 1, b: 2, c: 3 };
    const x = new deep.Object(v1);
    const y = new deep.Object(v1);
    const v2 = { a: 1, b: 2, c: 3 };
    const z = new deep.Object(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Object.symbol);
    expect(y.prev).toBe(deep.Object.symbol);
    expect(z.prev).toBe(deep.Object.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.Object(123)).toThrow('!Object');
  });
  it('deep.Promise', () => {
    const a = deep.Promise();
    const b = deep.Promise();
    expect(a).toBe(undefined);
    const v1 = new Promise(res => res(undefined));
    const x = new deep.Promise(v1);
    const y = new deep.Promise(v1);
    const v2 = new Promise(res => res(undefined));
    const z = new deep.Promise(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Promise.symbol);
    expect(y.prev).toBe(deep.Promise.symbol);
    expect(z.prev).toBe(deep.Promise.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.Promise(123)).toThrow('!Promise');
  });
  it('deep.Map', () => {
    const a = deep.Map();
    const b = deep.Map();
    expect(a).toBe(undefined);
    const v1 = new Map();
    const x = new deep.Map(v1);
    const y = new deep.Map(v1);
    const v2 = new Map();
    const z = new deep.Map(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Map.symbol);
    expect(y.prev).toBe(deep.Map.symbol);
    expect(z.prev).toBe(deep.Map.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.Map(123)).toThrow('!Map');
  });
  it('deep.WeakMap', () => {
    const a = deep.WeakMap();
    const b = deep.WeakMap();
    expect(a).toBe(undefined);
    const v1 = new WeakMap();
    const x = new deep.WeakMap(v1);
    const y = new deep.WeakMap(v1);
    const v2 = new WeakMap();
    const z = new deep.WeakMap(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.WeakMap.symbol);
    expect(y.prev).toBe(deep.WeakMap.symbol);
    expect(z.prev).toBe(deep.WeakMap.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.WeakMap(123)).toThrow('!WeakMap');
  });
  it('deep.Set', () => {
    const a = deep.Set();
    const b = deep.Set();
    expect(a).toBe(undefined);
    const v1 = new Set();
    const x = new deep.Set(v1);
    const y = new deep.Set(v1);
    const v2 = new Set();
    const z = new deep.Set(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Set.symbol);
    expect(y.prev).toBe(deep.Set.symbol);
    expect(z.prev).toBe(deep.Set.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.Set(123)).toThrow('!Set');
  });
  it('deep.WeakSet', () => {
    const a = deep.WeakSet();
    const b = deep.WeakSet();
    expect(a).toBe(undefined);
    const v1 = new WeakSet();
    const x = new deep.WeakSet(v1);
    const y = new deep.WeakSet(v1);
    const v2 = new WeakSet();
    const z = new deep.WeakSet(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.WeakSet.symbol);
    expect(y.prev).toBe(deep.WeakSet.symbol);
    expect(z.prev).toBe(deep.WeakSet.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.WeakSet(123)).toThrow('!WeakSet');
  });
  it('deep.Date', () => {
    const a = deep.Date();
    const b = deep.Date();
    expect(a).toBe(undefined);
    const v1 = new Date();
    const x = new deep.Date(v1);
    const y = new deep.Date(v1);
    const v2 = new Date();
    const z = new deep.Date(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Date.symbol);
    expect(y.prev).toBe(deep.Date.symbol);
    expect(z.prev).toBe(deep.Date.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.Date(123)).toThrow('!Date');
  });
  it('deep.RegExp', () => {
    const a = deep.RegExp(/a/);
    const b = deep.RegExp(/a/);
    expect(a).toBe(undefined);
    const v1 = /a/;
    const x = new deep.RegExp(v1);
    const y = new deep.RegExp(v1);
    const v2 = new RegExp(/a/);
    const z = new deep.RegExp(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.RegExp.symbol);
    expect(y.prev).toBe(deep.RegExp.symbol);
    expect(z.prev).toBe(deep.RegExp.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.RegExp(123)).toThrow('!RegExp');
  });
  it('deep.Error', () => {
    const a = deep.Error();
    const b = deep.Error();
    expect(a).toBe(undefined);
    const v1 = new Error();
    const x = new deep.Error(v1);
    const y = new deep.Error(v1);
    const v2 = new Error();
    const z = new deep.Error(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Error.symbol);
    expect(y.prev).toBe(deep.Error.symbol);
    expect(z.prev).toBe(deep.Error.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.Error(123)).toThrow('!Error');
  });
  const isBufferAvailable = typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function';
  (isBufferAvailable ? it : it.skip)('deep.Buffer', () => {
    const a = deep.Buffer();
    const b = deep.Buffer();
    expect(a).toBe(undefined);
    const v1 = Buffer.from([1, 2, 3]);
    const x = new deep.Buffer(v1);
    const y = new deep.Buffer(v1);
    const v2 = Buffer.from([4, 5, 6]);
    const z = new deep.Buffer(v2);
    expect(x.data).toStrictEqual(v1);
    expect(y.data).toStrictEqual(v1);
    expect(z.data).toStrictEqual(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Buffer.symbol);
    expect(y.prev).toBe(deep.Buffer.symbol);
    expect(z.prev).toBe(deep.Buffer.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.Buffer([1, 2, 3])).toThrow('!Buffer');
  });
  
  it('deep.ArrayBuffer', () => {
    const a = deep.ArrayBuffer();
    const b = deep.ArrayBuffer();
    expect(a).toBe(undefined);
    const v1 = new ArrayBuffer(8);
    const x = new deep.ArrayBuffer(v1);
    const y = new deep.ArrayBuffer(v1);
    const v2 = new ArrayBuffer(16);
    const z = new deep.ArrayBuffer(v2);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.ArrayBuffer.symbol);
    expect(y.prev).toBe(deep.ArrayBuffer.symbol);
    expect(z.prev).toBe(deep.ArrayBuffer.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
      expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.ArrayBuffer([1, 2, 3])).toThrow('!ArrayBuffer');
  });
  
  it('deep.TypedArray', () => {
    const a = deep.TypedArray();
    const b = deep.TypedArray();
    expect(a).toBe(undefined);
    const v1 = new Uint8Array([1, 2, 3]);
    const x = new deep.TypedArray(v1);
    const y = new deep.TypedArray(v1);
    const v2 = new Float32Array([4, 5, 6]);
    const z = new deep.TypedArray(v2);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.TypedArray.symbol);
    expect(y.prev).toBe(deep.TypedArray.symbol);
    expect(z.prev).toBe(deep.TypedArray.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.TypedArray([1, 2, 3])).toThrow('!TypedArray');
    expect(() => new deep.TypedArray(new DataView(new ArrayBuffer(8)))).toThrow('!TypedArray');
  });
  
  it('deep.DataView', () => {
    const a = deep.DataView();
    const b = deep.DataView();
    expect(a).toBe(undefined);
    const v1 = new DataView(new ArrayBuffer(8));
    const x = new deep.DataView(v1);
    const y = new deep.DataView(v1);
    const v2 = new DataView(new ArrayBuffer(16));
    const z = new deep.DataView(v2);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.DataView.symbol);
    expect(y.prev).toBe(deep.DataView.symbol);
    expect(z.prev).toBe(deep.DataView.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.DataView([1, 2, 3])).toThrow('!DataView');
    expect(() => new deep.DataView(new Uint8Array([1, 2, 3]))).toThrow('!DataView');
  });
  
  const isBlobAvailable = typeof Blob !== 'undefined';
  (isBlobAvailable ? it : it.skip)('deep.Blob', () => {
    const a = deep.Blob();
    const b = deep.Blob();
    expect(a).toBe(undefined);
    const v1 = new Blob(['abc']);
    const x = new deep.Blob(v1);
    const y = new deep.Blob(v1);
    const v2 = new Blob(['def']);
    const z = new deep.Blob(v2);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.prev).toBe(deep.Blob.symbol);
    expect(y.prev).toBe(deep.Blob.symbol);
    expect(z.prev).toBe(deep.Blob.symbol);
    expect(x.prevBy).toBe(deep.construct.symbol);
    expect(y.prevBy).toBe(deep.construct.symbol);
    expect(z.prevBy).toBe(deep.construct.symbol);
    expect(() => new deep.Blob([1, 2, 3])).toThrow('!Blob');
  });
  it('deep.Function', () => {
    expect(() => deep.Function()).toThrow('!Function');
    const v1 = () => 123;
    const x = new deep.Function(v1);
    const y = new deep.Function(v1);
    const v2 = () => 123;
    const z = new deep.Function(v2);
    expect(x.context.__proto__).toStrictEqual(deep.Function.context);
    expect(x.symbol).toBe(y.symbol);
    expect(x.symbol).not.toBe(z.symbol);
    expect(x.data).toBe(v1);
    expect(y.data).toBe(v1);
    expect(z.data).toBe(v2);
    expect(x.data).not.toBe(z.data);
    expect(x.prev).toBe(deep.Function.symbol);
    expect(y.prev).toBe(deep.Function.symbol);
    expect(z.prev).toBe(deep.Function.symbol);
    expect(() => new deep.Function(123)).toThrow('!Function');
  });
});
