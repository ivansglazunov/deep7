import { describe, it, expect } from '@jest/globals';
import Debug from './debug';
import { newDeep } from './deep';

const debug = Debug('query:test');

// –¢–µ—Å—Ç–æ–≤—ã–π –¥–∞—Ç–∞—Å–µ—Ç –¥–ª—è –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤ —Å–æ–≥–ª–∞—Å–Ω–æ QUERY2.md
function makeDataset(deep: any) {
  debug('üèóÔ∏è Creating test dataset');
  
  // –û—Å–Ω–æ–≤–Ω—ã–µ —Ç–∏–ø—ã
  const A = new deep();
  const a1 = new deep();
  const a2 = new deep();
  a1.type = A;
  a2.type = A;
  
  const B = new deep();
  const b1 = new deep();
  const b2 = new deep();
  b1.type = B;
  b2.type = B;
  b1.from = a1;
  b2.from = a1;
  
  const C = new deep();
  const c1 = new deep();
  const c2 = new deep();
  c1.type = C;
  c2.type = C;
  c1.to = a2;
  c2.to = a2;
  
  const str = new deep.String('abc');
  const D = new deep();
  const d1 = new deep();
  const d2 = new deep();
  d1.type = D;
  d2.type = D;
  d1.value = str;
  d2.value = str;
  
  debug('‚úÖ Test dataset created');
  return { A, a1, a2, B, b1, b2, C, c1, c2, D, d1, d2, str };
}

describe('manyRelation', () => {
  let deep: any;
  
  beforeEach(() => {
    debug('üß™ Setting up test environment for manyRelation');
    deep = newDeep();
  });
  
  describe('type relation', () => {
    it('should handle single type relation with tracking', () => {
      const { A, a1, a2 } = makeDataset(deep);
      
      // –ê–∫—Å–∏–æ–º–∞: a1.type –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∏–ø –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–∏ A –ª–∏–±–æ undefined
      expect(a1.type._id).toBe(A._id);
      
      // –ê–∫—Å–∏–æ–º–∞: a1.manyRelation('type') –¥–æ–ª–∂–µ–Ω –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å { A }
      const a1TypeSet = a1.manyRelation('type');
      expect(a1TypeSet.type.is(deep.Set)).toBe(true);
      expect(a1TypeSet.size).toBe(1);
      expect(a1TypeSet.has(A)).toBe(true);
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–∫–∏–Ω–≥–∞ - –∏–∑–º–µ–Ω–µ–Ω–∏–µ type –¥–æ–ª–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç
      let typeSetChanged = false;
      let addedElement = null;
      let deletedElement = null;
      
      a1TypeSet.on(deep.events.dataAdd, (element) => {
        addedElement = element;
        typeSetChanged = true;
      });
      
      a1TypeSet.on(deep.events.dataDelete, (element) => {
        deletedElement = element;  
        typeSetChanged = true;
      });
      
      // –ò–∑–º–µ–Ω—è–µ–º —Ç–∏–ø –Ω–∞ –Ω–æ–≤—ã–π
      const Y = new deep();
      a1.type = Y;
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ–±–Ω–æ–≤–∏–ª—Å—è
      expect(a1TypeSet.size).toBe(1);
      expect(a1TypeSet.has(Y)).toBe(true);
      expect(a1TypeSet.has(A)).toBe(false);
      expect(typeSetChanged).toBe(true);
      expect(addedElement).toBeTruthy();
      expect(deletedElement).toBeTruthy();
      
      debug('‚úÖ type relation tracking works correctly');
    });
  });
  
  describe('typed relation', () => {
    it('should handle multiple typed relation with tracking', () => {
      const { A, a1, a2 } = makeDataset(deep);
      
      // –ê–∫—Å–∏–æ–º–∞: A.typed –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–µ—Ç —Ç–µ—Ö –∫—Ç–æ —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–∞–Ω–Ω–æ–π –∞—Å—Å–æ—Ü–∏–∞—Ü–∏–µ–π { a1, a2 }
      const ATypedSet = A.manyRelation('typed');
      expect(ATypedSet.type.is(deep.Set)).toBe(true);
      expect(ATypedSet.size).toBe(2);
      expect(ATypedSet.has(a1)).toBe(true);
      expect(ATypedSet.has(a2)).toBe(true);
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–∫–∏–Ω–≥–∞ - —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —ç–∫–∑–µ–º–ø–ª—è—Ä–∞ —Ç–∏–ø–∞ A
      let addedElement = null;
      ATypedSet.on(deep.events.dataAdd, (element) => {
        addedElement = element;
      });
      
      const a3 = new deep();
      a3.type = A;
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –Ω–æ–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –¥–æ–±–∞–≤–∏–ª—Å—è –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
      expect(ATypedSet.size).toBe(3);
      expect(ATypedSet.has(a3)).toBe(true);
      expect(addedElement).toBeTruthy();
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–∫–∏–Ω–≥–∞ - —É–¥–∞–ª–µ–Ω–∏–µ —Å–≤—è–∑–∏ type
      let deletedElement = null;
      ATypedSet.on(deep.events.dataDelete, (element) => {
        deletedElement = element;
      });
      
      delete a1.type;
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç–ª–µ–º–µ–Ω—Ç —É–¥–∞–ª–∏–ª—Å—è –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
      expect(ATypedSet.size).toBe(2);
      expect(ATypedSet.has(a1)).toBe(false);
      expect(ATypedSet.has(a2)).toBe(true);
      expect(ATypedSet.has(a3)).toBe(true);
      expect(deletedElement).toBeTruthy();
      
      debug('‚úÖ typed relation tracking works correctly');
    });
  });
  
  describe('from/out relation', () => {
    it('should handle from/out relation with tracking', () => {
      const { a1, B, b1, b2 } = makeDataset(deep);
      
      // –ê–∫—Å–∏–æ–º–∞: b1.from –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ –∫—É–¥–∞ –¥–∞–Ω–Ω–∞—è –∞—Å—Å–æ—Ü–∏–∞—Ü–∏—è —Å—Å—ã–ª–∞–µ—Ç—Å—è –∫–∞–∫ –Ω–∞ from - a1 –∏–ª–∏ undefined
      expect(b1.from._id).toBe(a1._id);
      
      // –ê–∫—Å–∏–æ–º–∞: b1.manyRelation('from') –¥–æ–ª–∂–µ–Ω –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å { a1 }
      const b1FromSet = b1.manyRelation('from');
      expect(b1FromSet.type.is(deep.Set)).toBe(true);
      expect(b1FromSet.size).toBe(1);
      expect(b1FromSet.has(a1)).toBe(true);
      
      // –ê–∫—Å–∏–æ–º–∞: a1.out –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–µ—Ç —Ç–µ—Ö –∫—Ç–æ —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ –¥–∞–Ω–Ω—É—é –∞—Å—Å–æ—Ü–∏–∞—Ü–∏—é –∫–∞–∫ –Ω–∞ from { b1, b2 }
      const a1OutSet = a1.manyRelation('out');
      expect(a1OutSet.type.is(deep.Set)).toBe(true);
      expect(a1OutSet.size).toBe(2);
      expect(a1OutSet.has(b1)).toBe(true);
      expect(a1OutSet.has(b2)).toBe(true);
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–∫–∏–Ω–≥–∞ - –∏–∑–º–µ–Ω–µ–Ω–∏–µ from –¥–æ–ª–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
      let fromSetChanged = false;
      let outSetChanged = false;
      
      b1FromSet.on(deep.events.dataChanged, () => { fromSetChanged = true; });
      a1OutSet.on(deep.events.dataChanged, () => { outSetChanged = true; });
      
      const newTarget = new deep();
      b1.from = newTarget;
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
      expect(b1FromSet.has(newTarget)).toBe(true);
      expect(b1FromSet.has(a1)).toBe(false);
      expect(a1OutSet.has(b1)).toBe(false);
      expect(fromSetChanged).toBe(true);
      expect(outSetChanged).toBe(true);
      
      debug('‚úÖ from/out relation tracking works correctly');
    });
  });
  
  describe('to/in relation', () => {
    it('should handle to/in relation with tracking', () => {
      const { a2, C, c1, c2 } = makeDataset(deep);
      
      // –ê–∫—Å–∏–æ–º–∞: c1.to –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ –∫—É–¥–∞ –¥–∞–Ω–Ω–∞—è –∞—Å—Å–æ—Ü–∏–∞—Ü–∏—è —Å—Å—ã–ª–∞–µ—Ç—Å—è –∫–∞–∫ –Ω–∞ to - a2 –∏–ª–∏ undefined
      expect(c1.to._id).toBe(a2._id);
      
      // –ê–∫—Å–∏–æ–º–∞: c1.manyRelation('to') –¥–æ–ª–∂–µ–Ω –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å { a2 }
      const c1ToSet = c1.manyRelation('to');
      expect(c1ToSet.type.is(deep.Set)).toBe(true);
      expect(c1ToSet.size).toBe(1);
      expect(c1ToSet.has(a2)).toBe(true);
      
      // –ê–∫—Å–∏–æ–º–∞: a2.in –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–µ—Ç —Ç–µ—Ö –∫—Ç–æ —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ –¥–∞–Ω–Ω—É—é –∞—Å—Å–æ—Ü–∏–∞—Ü–∏—é –∫–∞–∫ –Ω–∞ to { c1, c2 }
      const a2InSet = a2.manyRelation('in');
      expect(a2InSet.type.is(deep.Set)).toBe(true);
      expect(a2InSet.size).toBe(2);
      expect(a2InSet.has(c1)).toBe(true);
      expect(a2InSet.has(c2)).toBe(true);
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–∫–∏–Ω–≥–∞ - —É–¥–∞–ª–µ–Ω–∏–µ to –¥–æ–ª–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
      let toSetChanged = false;
      let inSetChanged = false;
      
      c1ToSet.on(deep.events.dataChanged, () => { toSetChanged = true; });
      a2InSet.on(deep.events.dataChanged, () => { inSetChanged = true; });
      
      delete c1.to;
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è
      expect(c1ToSet.size).toBe(0);
      expect(a2InSet.has(c1)).toBe(false);
      expect(a2InSet.has(c2)).toBe(true);
      expect(toSetChanged).toBe(true);
      expect(inSetChanged).toBe(true);
      
      debug('‚úÖ to/in relation tracking works correctly');
    });
  });
  
  describe('value/valued relation', () => {
    it('should handle value/valued relation with tracking', () => {
      const { str, D, d1, d2 } = makeDataset(deep);
      
      // –ê–∫—Å–∏–æ–º–∞: d1.value –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ –∫—É–¥–∞ –¥–∞–Ω–Ω–∞—è –∞—Å—Å–æ—Ü–∏–∞—Ü–∏—è —Å—Å—ã–ª–∞–µ—Ç—Å—è –∫–∞–∫ –Ω–∞ .value - str –∏–ª–∏ undefined
      expect(d1.value._id).toBe(str._id);
      
      // –ê–∫—Å–∏–æ–º–∞: d1.manyRelation('value') –¥–æ–ª–∂–µ–Ω –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å { str }
      const d1ValueSet = d1.manyRelation('value');
      expect(d1ValueSet.type.is(deep.Set)).toBe(true);
      expect(d1ValueSet.size).toBe(1);
      expect(d1ValueSet.has(str)).toBe(true);
      
      // –ê–∫—Å–∏–æ–º–∞: str.valued –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–µ—Ç —Ç–µ—Ö –∫—Ç–æ —Å—Å—ã–ª–∞–µ—Ç—Å—è –Ω–∞ –¥–∞–Ω–Ω—É—é –∞—Å—Å–æ—Ü–∏–∞—Ü–∏—é –∫–∞–∫ –Ω–∞ value { d1, d2 }
      const strValuedSet = str.manyRelation('valued');
      expect(strValuedSet.type.is(deep.Set)).toBe(true);
      expect(strValuedSet.size).toBe(2);
      expect(strValuedSet.has(d1)).toBe(true);
      expect(strValuedSet.has(d2)).toBe(true);
      
      // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–∫–∏–Ω–≥–∞ - —É–¥–∞–ª–µ–Ω–∏–µ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ value
      let valueSetChanged = false;
      let valuedSetChanged = false;
      
      d1ValueSet.on(deep.events.dataChanged, () => { valueSetChanged = true; });
      strValuedSet.on(deep.events.dataChanged, () => { valuedSetChanged = true; });
      
      // –£–¥–∞–ª—è–µ–º value
      delete d1.value;
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ d1 –∏—Å—á–µ–∑ –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
      expect(d1ValueSet.size).toBe(0);
      expect(strValuedSet.has(d1)).toBe(false);
      expect(strValuedSet.has(d2)).toBe(true);
      expect(valueSetChanged).toBe(true);
      expect(valuedSetChanged).toBe(true);
      
      // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º value
      valueSetChanged = false;
      valuedSetChanged = false;
      
      d1.value = str;
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ d1 –≤–µ—Ä–Ω—É–ª—Å—è –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
      expect(d1ValueSet.size).toBe(1);
      expect(d1ValueSet.has(str)).toBe(true);
      expect(strValuedSet.has(d1)).toBe(true);
      expect(valueSetChanged).toBe(true);
      expect(valuedSetChanged).toBe(true);
      
      debug('‚úÖ value/valued relation tracking works correctly');
    });
  });
}); 